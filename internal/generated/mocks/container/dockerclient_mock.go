// Code generated by mockery v2.52.2. DO NOT EDIT.

package mocks

import (
	context "context"

	events "github.com/docker/docker/api/types/events"
	image "github.com/docker/docker/api/types/image"

	io "io"

	mock "github.com/stretchr/testify/mock"

	network "github.com/docker/docker/api/types/network"

	typescontainer "github.com/docker/docker/api/types/container"

	v1 "github.com/opencontainers/image-spec/specs-go/v1"
)

// DockerClient is an autogenerated mock type for the DockerClient type
type DockerClient struct {
	mock.Mock
}

type DockerClient_Expecter struct {
	mock *mock.Mock
}

func (_m *DockerClient) EXPECT() *DockerClient_Expecter {
	return &DockerClient_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with no fields
func (_m *DockerClient) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerClient_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type DockerClient_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *DockerClient_Expecter) Close() *DockerClient_Close_Call {
	return &DockerClient_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *DockerClient_Close_Call) Run(run func()) *DockerClient_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerClient_Close_Call) Return(_a0 error) *DockerClient_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerClient_Close_Call) RunAndReturn(run func() error) *DockerClient_Close_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerCreate provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5
func (_m *DockerClient) ContainerCreate(_a0 context.Context, _a1 *typescontainer.Config, _a2 *typescontainer.HostConfig, _a3 *network.NetworkingConfig, _a4 *v1.Platform, _a5 string) (typescontainer.CreateResponse, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5)

	if len(ret) == 0 {
		panic("no return value specified for ContainerCreate")
	}

	var r0 typescontainer.CreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *typescontainer.Config, *typescontainer.HostConfig, *network.NetworkingConfig, *v1.Platform, string) (typescontainer.CreateResponse, error)); ok {
		return rf(_a0, _a1, _a2, _a3, _a4, _a5)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *typescontainer.Config, *typescontainer.HostConfig, *network.NetworkingConfig, *v1.Platform, string) typescontainer.CreateResponse); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5)
	} else {
		r0 = ret.Get(0).(typescontainer.CreateResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *typescontainer.Config, *typescontainer.HostConfig, *network.NetworkingConfig, *v1.Platform, string) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerClient_ContainerCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerCreate'
type DockerClient_ContainerCreate_Call struct {
	*mock.Call
}

// ContainerCreate is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *typescontainer.Config
//   - _a2 *typescontainer.HostConfig
//   - _a3 *network.NetworkingConfig
//   - _a4 *v1.Platform
//   - _a5 string
func (_e *DockerClient_Expecter) ContainerCreate(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}, _a4 interface{}, _a5 interface{}) *DockerClient_ContainerCreate_Call {
	return &DockerClient_ContainerCreate_Call{Call: _e.mock.On("ContainerCreate", _a0, _a1, _a2, _a3, _a4, _a5)}
}

func (_c *DockerClient_ContainerCreate_Call) Run(run func(_a0 context.Context, _a1 *typescontainer.Config, _a2 *typescontainer.HostConfig, _a3 *network.NetworkingConfig, _a4 *v1.Platform, _a5 string)) *DockerClient_ContainerCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*typescontainer.Config), args[2].(*typescontainer.HostConfig), args[3].(*network.NetworkingConfig), args[4].(*v1.Platform), args[5].(string))
	})
	return _c
}

func (_c *DockerClient_ContainerCreate_Call) Return(_a0 typescontainer.CreateResponse, _a1 error) *DockerClient_ContainerCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerClient_ContainerCreate_Call) RunAndReturn(run func(context.Context, *typescontainer.Config, *typescontainer.HostConfig, *network.NetworkingConfig, *v1.Platform, string) (typescontainer.CreateResponse, error)) *DockerClient_ContainerCreate_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerList provides a mock function with given fields: _a0, _a1
func (_m *DockerClient) ContainerList(_a0 context.Context, _a1 typescontainer.ListOptions) ([]typescontainer.Summary, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ContainerList")
	}

	var r0 []typescontainer.Summary
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, typescontainer.ListOptions) ([]typescontainer.Summary, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, typescontainer.ListOptions) []typescontainer.Summary); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]typescontainer.Summary)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, typescontainer.ListOptions) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerClient_ContainerList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerList'
type DockerClient_ContainerList_Call struct {
	*mock.Call
}

// ContainerList is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 typescontainer.ListOptions
func (_e *DockerClient_Expecter) ContainerList(_a0 interface{}, _a1 interface{}) *DockerClient_ContainerList_Call {
	return &DockerClient_ContainerList_Call{Call: _e.mock.On("ContainerList", _a0, _a1)}
}

func (_c *DockerClient_ContainerList_Call) Run(run func(_a0 context.Context, _a1 typescontainer.ListOptions)) *DockerClient_ContainerList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(typescontainer.ListOptions))
	})
	return _c
}

func (_c *DockerClient_ContainerList_Call) Return(_a0 []typescontainer.Summary, _a1 error) *DockerClient_ContainerList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerClient_ContainerList_Call) RunAndReturn(run func(context.Context, typescontainer.ListOptions) ([]typescontainer.Summary, error)) *DockerClient_ContainerList_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerLogs provides a mock function with given fields: _a0, _a1, _a2
func (_m *DockerClient) ContainerLogs(_a0 context.Context, _a1 string, _a2 typescontainer.LogsOptions) (io.ReadCloser, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for ContainerLogs")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, typescontainer.LogsOptions) (io.ReadCloser, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, typescontainer.LogsOptions) io.ReadCloser); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, typescontainer.LogsOptions) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerClient_ContainerLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerLogs'
type DockerClient_ContainerLogs_Call struct {
	*mock.Call
}

// ContainerLogs is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 typescontainer.LogsOptions
func (_e *DockerClient_Expecter) ContainerLogs(_a0 interface{}, _a1 interface{}, _a2 interface{}) *DockerClient_ContainerLogs_Call {
	return &DockerClient_ContainerLogs_Call{Call: _e.mock.On("ContainerLogs", _a0, _a1, _a2)}
}

func (_c *DockerClient_ContainerLogs_Call) Run(run func(_a0 context.Context, _a1 string, _a2 typescontainer.LogsOptions)) *DockerClient_ContainerLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(typescontainer.LogsOptions))
	})
	return _c
}

func (_c *DockerClient_ContainerLogs_Call) Return(_a0 io.ReadCloser, _a1 error) *DockerClient_ContainerLogs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerClient_ContainerLogs_Call) RunAndReturn(run func(context.Context, string, typescontainer.LogsOptions) (io.ReadCloser, error)) *DockerClient_ContainerLogs_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerRemove provides a mock function with given fields: _a0, _a1, _a2
func (_m *DockerClient) ContainerRemove(_a0 context.Context, _a1 string, _a2 typescontainer.RemoveOptions) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for ContainerRemove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, typescontainer.RemoveOptions) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerClient_ContainerRemove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerRemove'
type DockerClient_ContainerRemove_Call struct {
	*mock.Call
}

// ContainerRemove is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 typescontainer.RemoveOptions
func (_e *DockerClient_Expecter) ContainerRemove(_a0 interface{}, _a1 interface{}, _a2 interface{}) *DockerClient_ContainerRemove_Call {
	return &DockerClient_ContainerRemove_Call{Call: _e.mock.On("ContainerRemove", _a0, _a1, _a2)}
}

func (_c *DockerClient_ContainerRemove_Call) Run(run func(_a0 context.Context, _a1 string, _a2 typescontainer.RemoveOptions)) *DockerClient_ContainerRemove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(typescontainer.RemoveOptions))
	})
	return _c
}

func (_c *DockerClient_ContainerRemove_Call) Return(_a0 error) *DockerClient_ContainerRemove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerClient_ContainerRemove_Call) RunAndReturn(run func(context.Context, string, typescontainer.RemoveOptions) error) *DockerClient_ContainerRemove_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerStart provides a mock function with given fields: _a0, _a1, _a2
func (_m *DockerClient) ContainerStart(_a0 context.Context, _a1 string, _a2 typescontainer.StartOptions) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for ContainerStart")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, typescontainer.StartOptions) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerClient_ContainerStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerStart'
type DockerClient_ContainerStart_Call struct {
	*mock.Call
}

// ContainerStart is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 typescontainer.StartOptions
func (_e *DockerClient_Expecter) ContainerStart(_a0 interface{}, _a1 interface{}, _a2 interface{}) *DockerClient_ContainerStart_Call {
	return &DockerClient_ContainerStart_Call{Call: _e.mock.On("ContainerStart", _a0, _a1, _a2)}
}

func (_c *DockerClient_ContainerStart_Call) Run(run func(_a0 context.Context, _a1 string, _a2 typescontainer.StartOptions)) *DockerClient_ContainerStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(typescontainer.StartOptions))
	})
	return _c
}

func (_c *DockerClient_ContainerStart_Call) Return(_a0 error) *DockerClient_ContainerStart_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerClient_ContainerStart_Call) RunAndReturn(run func(context.Context, string, typescontainer.StartOptions) error) *DockerClient_ContainerStart_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerStats provides a mock function with given fields: _a0, _a1, _a2
func (_m *DockerClient) ContainerStats(_a0 context.Context, _a1 string, _a2 bool) (typescontainer.StatsResponseReader, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for ContainerStats")
	}

	var r0 typescontainer.StatsResponseReader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) (typescontainer.StatsResponseReader, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) typescontainer.StatsResponseReader); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(typescontainer.StatsResponseReader)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerClient_ContainerStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerStats'
type DockerClient_ContainerStats_Call struct {
	*mock.Call
}

// ContainerStats is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 bool
func (_e *DockerClient_Expecter) ContainerStats(_a0 interface{}, _a1 interface{}, _a2 interface{}) *DockerClient_ContainerStats_Call {
	return &DockerClient_ContainerStats_Call{Call: _e.mock.On("ContainerStats", _a0, _a1, _a2)}
}

func (_c *DockerClient_ContainerStats_Call) Run(run func(_a0 context.Context, _a1 string, _a2 bool)) *DockerClient_ContainerStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *DockerClient_ContainerStats_Call) Return(_a0 typescontainer.StatsResponseReader, _a1 error) *DockerClient_ContainerStats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerClient_ContainerStats_Call) RunAndReturn(run func(context.Context, string, bool) (typescontainer.StatsResponseReader, error)) *DockerClient_ContainerStats_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerStop provides a mock function with given fields: _a0, _a1, _a2
func (_m *DockerClient) ContainerStop(_a0 context.Context, _a1 string, _a2 typescontainer.StopOptions) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for ContainerStop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, typescontainer.StopOptions) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerClient_ContainerStop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerStop'
type DockerClient_ContainerStop_Call struct {
	*mock.Call
}

// ContainerStop is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 typescontainer.StopOptions
func (_e *DockerClient_Expecter) ContainerStop(_a0 interface{}, _a1 interface{}, _a2 interface{}) *DockerClient_ContainerStop_Call {
	return &DockerClient_ContainerStop_Call{Call: _e.mock.On("ContainerStop", _a0, _a1, _a2)}
}

func (_c *DockerClient_ContainerStop_Call) Run(run func(_a0 context.Context, _a1 string, _a2 typescontainer.StopOptions)) *DockerClient_ContainerStop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(typescontainer.StopOptions))
	})
	return _c
}

func (_c *DockerClient_ContainerStop_Call) Return(_a0 error) *DockerClient_ContainerStop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerClient_ContainerStop_Call) RunAndReturn(run func(context.Context, string, typescontainer.StopOptions) error) *DockerClient_ContainerStop_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerWait provides a mock function with given fields: _a0, _a1, _a2
func (_m *DockerClient) ContainerWait(_a0 context.Context, _a1 string, _a2 typescontainer.WaitCondition) (<-chan typescontainer.WaitResponse, <-chan error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for ContainerWait")
	}

	var r0 <-chan typescontainer.WaitResponse
	var r1 <-chan error
	if rf, ok := ret.Get(0).(func(context.Context, string, typescontainer.WaitCondition) (<-chan typescontainer.WaitResponse, <-chan error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, typescontainer.WaitCondition) <-chan typescontainer.WaitResponse); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan typescontainer.WaitResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, typescontainer.WaitCondition) <-chan error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(<-chan error)
		}
	}

	return r0, r1
}

// DockerClient_ContainerWait_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerWait'
type DockerClient_ContainerWait_Call struct {
	*mock.Call
}

// ContainerWait is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 typescontainer.WaitCondition
func (_e *DockerClient_Expecter) ContainerWait(_a0 interface{}, _a1 interface{}, _a2 interface{}) *DockerClient_ContainerWait_Call {
	return &DockerClient_ContainerWait_Call{Call: _e.mock.On("ContainerWait", _a0, _a1, _a2)}
}

func (_c *DockerClient_ContainerWait_Call) Run(run func(_a0 context.Context, _a1 string, _a2 typescontainer.WaitCondition)) *DockerClient_ContainerWait_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(typescontainer.WaitCondition))
	})
	return _c
}

func (_c *DockerClient_ContainerWait_Call) Return(_a0 <-chan typescontainer.WaitResponse, _a1 <-chan error) *DockerClient_ContainerWait_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerClient_ContainerWait_Call) RunAndReturn(run func(context.Context, string, typescontainer.WaitCondition) (<-chan typescontainer.WaitResponse, <-chan error)) *DockerClient_ContainerWait_Call {
	_c.Call.Return(run)
	return _c
}

// CopyToContainer provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *DockerClient) CopyToContainer(_a0 context.Context, _a1 string, _a2 string, _a3 io.Reader, _a4 typescontainer.CopyToContainerOptions) error {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	if len(ret) == 0 {
		panic("no return value specified for CopyToContainer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, io.Reader, typescontainer.CopyToContainerOptions) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerClient_CopyToContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyToContainer'
type DockerClient_CopyToContainer_Call struct {
	*mock.Call
}

// CopyToContainer is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 string
//   - _a3 io.Reader
//   - _a4 typescontainer.CopyToContainerOptions
func (_e *DockerClient_Expecter) CopyToContainer(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}, _a4 interface{}) *DockerClient_CopyToContainer_Call {
	return &DockerClient_CopyToContainer_Call{Call: _e.mock.On("CopyToContainer", _a0, _a1, _a2, _a3, _a4)}
}

func (_c *DockerClient_CopyToContainer_Call) Run(run func(_a0 context.Context, _a1 string, _a2 string, _a3 io.Reader, _a4 typescontainer.CopyToContainerOptions)) *DockerClient_CopyToContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(io.Reader), args[4].(typescontainer.CopyToContainerOptions))
	})
	return _c
}

func (_c *DockerClient_CopyToContainer_Call) Return(_a0 error) *DockerClient_CopyToContainer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerClient_CopyToContainer_Call) RunAndReturn(run func(context.Context, string, string, io.Reader, typescontainer.CopyToContainerOptions) error) *DockerClient_CopyToContainer_Call {
	_c.Call.Return(run)
	return _c
}

// Events provides a mock function with given fields: _a0, _a1
func (_m *DockerClient) Events(_a0 context.Context, _a1 events.ListOptions) (<-chan events.Message, <-chan error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Events")
	}

	var r0 <-chan events.Message
	var r1 <-chan error
	if rf, ok := ret.Get(0).(func(context.Context, events.ListOptions) (<-chan events.Message, <-chan error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, events.ListOptions) <-chan events.Message); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan events.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, events.ListOptions) <-chan error); ok {
		r1 = rf(_a0, _a1)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(<-chan error)
		}
	}

	return r0, r1
}

// DockerClient_Events_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Events'
type DockerClient_Events_Call struct {
	*mock.Call
}

// Events is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 events.ListOptions
func (_e *DockerClient_Expecter) Events(_a0 interface{}, _a1 interface{}) *DockerClient_Events_Call {
	return &DockerClient_Events_Call{Call: _e.mock.On("Events", _a0, _a1)}
}

func (_c *DockerClient_Events_Call) Run(run func(_a0 context.Context, _a1 events.ListOptions)) *DockerClient_Events_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(events.ListOptions))
	})
	return _c
}

func (_c *DockerClient_Events_Call) Return(_a0 <-chan events.Message, _a1 <-chan error) *DockerClient_Events_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerClient_Events_Call) RunAndReturn(run func(context.Context, events.ListOptions) (<-chan events.Message, <-chan error)) *DockerClient_Events_Call {
	_c.Call.Return(run)
	return _c
}

// ImagePull provides a mock function with given fields: _a0, _a1, _a2
func (_m *DockerClient) ImagePull(_a0 context.Context, _a1 string, _a2 image.PullOptions) (io.ReadCloser, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for ImagePull")
	}

	var r0 io.ReadCloser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, image.PullOptions) (io.ReadCloser, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, image.PullOptions) io.ReadCloser); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, image.PullOptions) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerClient_ImagePull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImagePull'
type DockerClient_ImagePull_Call struct {
	*mock.Call
}

// ImagePull is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 image.PullOptions
func (_e *DockerClient_Expecter) ImagePull(_a0 interface{}, _a1 interface{}, _a2 interface{}) *DockerClient_ImagePull_Call {
	return &DockerClient_ImagePull_Call{Call: _e.mock.On("ImagePull", _a0, _a1, _a2)}
}

func (_c *DockerClient_ImagePull_Call) Run(run func(_a0 context.Context, _a1 string, _a2 image.PullOptions)) *DockerClient_ImagePull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(image.PullOptions))
	})
	return _c
}

func (_c *DockerClient_ImagePull_Call) Return(_a0 io.ReadCloser, _a1 error) *DockerClient_ImagePull_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerClient_ImagePull_Call) RunAndReturn(run func(context.Context, string, image.PullOptions) (io.ReadCloser, error)) *DockerClient_ImagePull_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkConnect provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *DockerClient) NetworkConnect(_a0 context.Context, _a1 string, _a2 string, _a3 *network.EndpointSettings) error {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for NetworkConnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *network.EndpointSettings) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerClient_NetworkConnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkConnect'
type DockerClient_NetworkConnect_Call struct {
	*mock.Call
}

// NetworkConnect is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 string
//   - _a3 *network.EndpointSettings
func (_e *DockerClient_Expecter) NetworkConnect(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}) *DockerClient_NetworkConnect_Call {
	return &DockerClient_NetworkConnect_Call{Call: _e.mock.On("NetworkConnect", _a0, _a1, _a2, _a3)}
}

func (_c *DockerClient_NetworkConnect_Call) Run(run func(_a0 context.Context, _a1 string, _a2 string, _a3 *network.EndpointSettings)) *DockerClient_NetworkConnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*network.EndpointSettings))
	})
	return _c
}

func (_c *DockerClient_NetworkConnect_Call) Return(_a0 error) *DockerClient_NetworkConnect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerClient_NetworkConnect_Call) RunAndReturn(run func(context.Context, string, string, *network.EndpointSettings) error) *DockerClient_NetworkConnect_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkCreate provides a mock function with given fields: _a0, _a1, _a2
func (_m *DockerClient) NetworkCreate(_a0 context.Context, _a1 string, _a2 network.CreateOptions) (network.CreateResponse, error) {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for NetworkCreate")
	}

	var r0 network.CreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, network.CreateOptions) (network.CreateResponse, error)); ok {
		return rf(_a0, _a1, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, network.CreateOptions) network.CreateResponse); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(network.CreateResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, network.CreateOptions) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerClient_NetworkCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkCreate'
type DockerClient_NetworkCreate_Call struct {
	*mock.Call
}

// NetworkCreate is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 network.CreateOptions
func (_e *DockerClient_Expecter) NetworkCreate(_a0 interface{}, _a1 interface{}, _a2 interface{}) *DockerClient_NetworkCreate_Call {
	return &DockerClient_NetworkCreate_Call{Call: _e.mock.On("NetworkCreate", _a0, _a1, _a2)}
}

func (_c *DockerClient_NetworkCreate_Call) Run(run func(_a0 context.Context, _a1 string, _a2 network.CreateOptions)) *DockerClient_NetworkCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(network.CreateOptions))
	})
	return _c
}

func (_c *DockerClient_NetworkCreate_Call) Return(_a0 network.CreateResponse, _a1 error) *DockerClient_NetworkCreate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerClient_NetworkCreate_Call) RunAndReturn(run func(context.Context, string, network.CreateOptions) (network.CreateResponse, error)) *DockerClient_NetworkCreate_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkDisconnect provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *DockerClient) NetworkDisconnect(_a0 context.Context, _a1 string, _a2 string, _a3 bool) error {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	if len(ret) == 0 {
		panic("no return value specified for NetworkDisconnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerClient_NetworkDisconnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkDisconnect'
type DockerClient_NetworkDisconnect_Call struct {
	*mock.Call
}

// NetworkDisconnect is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
//   - _a2 string
//   - _a3 bool
func (_e *DockerClient_Expecter) NetworkDisconnect(_a0 interface{}, _a1 interface{}, _a2 interface{}, _a3 interface{}) *DockerClient_NetworkDisconnect_Call {
	return &DockerClient_NetworkDisconnect_Call{Call: _e.mock.On("NetworkDisconnect", _a0, _a1, _a2, _a3)}
}

func (_c *DockerClient_NetworkDisconnect_Call) Run(run func(_a0 context.Context, _a1 string, _a2 string, _a3 bool)) *DockerClient_NetworkDisconnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *DockerClient_NetworkDisconnect_Call) Return(_a0 error) *DockerClient_NetworkDisconnect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerClient_NetworkDisconnect_Call) RunAndReturn(run func(context.Context, string, string, bool) error) *DockerClient_NetworkDisconnect_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkList provides a mock function with given fields: _a0, _a1
func (_m *DockerClient) NetworkList(_a0 context.Context, _a1 network.ListOptions) ([]network.Summary, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for NetworkList")
	}

	var r0 []network.Summary
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, network.ListOptions) ([]network.Summary, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, network.ListOptions) []network.Summary); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]network.Summary)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, network.ListOptions) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerClient_NetworkList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkList'
type DockerClient_NetworkList_Call struct {
	*mock.Call
}

// NetworkList is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 network.ListOptions
func (_e *DockerClient_Expecter) NetworkList(_a0 interface{}, _a1 interface{}) *DockerClient_NetworkList_Call {
	return &DockerClient_NetworkList_Call{Call: _e.mock.On("NetworkList", _a0, _a1)}
}

func (_c *DockerClient_NetworkList_Call) Run(run func(_a0 context.Context, _a1 network.ListOptions)) *DockerClient_NetworkList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(network.ListOptions))
	})
	return _c
}

func (_c *DockerClient_NetworkList_Call) Return(_a0 []network.Summary, _a1 error) *DockerClient_NetworkList_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerClient_NetworkList_Call) RunAndReturn(run func(context.Context, network.ListOptions) ([]network.Summary, error)) *DockerClient_NetworkList_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkRemove provides a mock function with given fields: _a0, _a1
func (_m *DockerClient) NetworkRemove(_a0 context.Context, _a1 string) error {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for NetworkRemove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerClient_NetworkRemove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkRemove'
type DockerClient_NetworkRemove_Call struct {
	*mock.Call
}

// NetworkRemove is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 string
func (_e *DockerClient_Expecter) NetworkRemove(_a0 interface{}, _a1 interface{}) *DockerClient_NetworkRemove_Call {
	return &DockerClient_NetworkRemove_Call{Call: _e.mock.On("NetworkRemove", _a0, _a1)}
}

func (_c *DockerClient_NetworkRemove_Call) Run(run func(_a0 context.Context, _a1 string)) *DockerClient_NetworkRemove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *DockerClient_NetworkRemove_Call) Return(_a0 error) *DockerClient_NetworkRemove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerClient_NetworkRemove_Call) RunAndReturn(run func(context.Context, string) error) *DockerClient_NetworkRemove_Call {
	_c.Call.Return(run)
	return _c
}

// NewDockerClient creates a new instance of DockerClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDockerClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *DockerClient {
	mock := &DockerClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
